[{"title":"Redis过期策略和内存淘汰策略","url":"/2019/05/20/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/","content":"<h3 id=\"Redis处理过期的key\"><a href=\"#Redis处理过期的key\" class=\"headerlink\" title=\"Redis处理过期的key\"></a>Redis处理过期的key</h3><p>Redis会将每个设置了过期时间的key保存在一个独立的字典中，以后会定期扫描这个字典来删除过期了的key。除了定期扫描删除策略之外，Redis同时采用惰性删除策略，在客户端访问key的时候，Redis会对这个key做过期检查，如果key已过期，则删除这个key。</p>\n<a id=\"more\"></a>\n<h3 id=\"定期扫描策略\"><a href=\"#定期扫描策略\" class=\"headerlink\" title=\"定期扫描策略\"></a>定期扫描策略</h3><p>redis默认会每秒进行10次过期扫描，过期扫描的时候不会扫描过期字典中所有的key，而是采用一种贪心策略：</p>\n<ul>\n<li>每次从过期字典中获取20个key。</li>\n<li>将这20个key中过期的key删除</li>\n<li>如果过期的key的比例超过25%，则重复1步骤</li>\n</ul>\n<p>为了保证扫描不出现循环过度，导致线程卡死，一次扫描时间的上限为25ms。 如果Redis中所有的key在同一时间都过期了，Redis会持续扫描，从而造成顿卡现象，所以在设计缓存时间的时候，要给过期时间设计一个随机值，让过期的key不在同一时间都过期。</p>\n<h3 id=\"从库过期策略\"><a href=\"#从库过期策略\" class=\"headerlink\" title=\"从库过期策略\"></a>从库过期策略</h3><p>从库不会进行过期扫描，主库在key过期的时候，会在AOF文件中写入一条del命令，从库是通过同步主库的时候执行该命令删除过期的key，由于同步操作是异步的，所以会存在主库删除了但是从库还存在这个key的现象。</p>\n<h3 id=\"内存淘汰策略\"><a href=\"#内存淘汰策略\" class=\"headerlink\" title=\"内存淘汰策略\"></a>内存淘汰策略</h3><p>当Redis使用内存超过物理内存限制的时候，内存的数据就开始和磁盘进行交换，这个操作是很耗时的，会严重降低Redis的性能。在Redis中，通过maxmemory限制了最大内存的使用。如果超过设置的值，Redis提供了多种策略决定如何释放内存。</p>\n<ul>\n<li>noeviction：不会继续服务写请求(除了del命令外),可以继续读请求，这样线上的读操作还可以继续，但是遇到写的操作将不可以，Redis默认为该策略。</li>\n<li>volatile-lru：淘汰设置了过期时间的key,最少使用的key优先淘汰。</li>\n<li>volatile-ttl：淘汰设置了过期时间的key，key的ttl时间越小的优先淘汰。</li>\n<li>volatile-random：淘汰设置了过期时间的key，随机淘汰。</li>\n<li>allkeys-lru：淘汰所有的key,最少使用的key优先淘汰。</li>\n<li>allkeys-random：淘汰所有的key，随机淘汰。</li>\n</ul>\n<h4 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h4><p>删除指令del会直接释放对象的内存，但如果对象特别大，删除操作会导致线程顿卡。redis为解决该问题，在4.0版本中引入了unlink命令，他对删除操作进行懒删除，将释放内存的操作放入后台的异步线程处理。</p>\n<p>Redis提供的flushdb和flushall指令可以清空数据库，这个操作很耗时，在4.0后，通过在指令后面增加async参数，异步处理清空操作。</p>\n","tags":["Redis"]},{"title":"Redis持久化：AOF","url":"/2019/04/20/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9AAOF/","content":"<h3 id=\"什么是AOF持久化\"><a href=\"#什么是AOF持久化\" class=\"headerlink\" title=\"什么是AOF持久化\"></a>什么是AOF持久化</h3><p>Redis有两种持久化方式，RDB和AOF。RDB是将Redis中的数据保存一份到RDB文件中，而AOF不是保存键值对数据，而是保存服务器执行的写命令来记录数据库的状态。</p>\n<a id=\"more\"></a>\n<h3 id=\"AOF持久化的实现原理\"><a href=\"#AOF持久化的实现原理\" class=\"headerlink\" title=\"AOF持久化的实现原理\"></a>AOF持久化的实现原理</h3><p>AOF持久化的实现可以分为三个步骤：命令追加、文件写入、文件同步。</p>\n<h5 id=\"命令追加\"><a href=\"#命令追加\" class=\"headerlink\" title=\"命令追加\"></a>命令追加</h5><p>当Redis的AOF持久化功能打开之后，服务器在执行完一个写入命令后，将会以协议格式将被写入的命令追加到服务器的aof_buf缓存区的末尾。打开AOF持久化的设置在redis.conf中，配置项如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 默认是没有打开的，设置为yes则为打开状态</span><br><span class=\"line\">appendonly no</span><br></pre></td></tr></table></figure>\n<h5 id=\"文件写入和同步\"><a href=\"#文件写入和同步\" class=\"headerlink\" title=\"文件写入和同步\"></a>文件写入和同步</h5><p>服务器每次结束一个事件循环之前，服务器就会调用flushAppendOlnyFile函数，判断是否需要将aof_buf中的内容写入AOF文件中。flushAppendOlnyFile函数会根据Redis服务器配置文件中appendfsync的值做不同的处理，配置项在redis.conf中，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#默认为everysec 可选值还有no、always</span><br><span class=\"line\">appendfsync everysec</span><br></pre></td></tr></table></figure>\n<p>每一个值的含义如下：</p>\n<ul>\n<li>no：将aof_buf中的所有内容写入AOF文件，但不对AOF文件进行同步，何时同步需要操作系统决定。</li>\n<li>everysec：将aof_buf中的所有内容写入AOF文件，如果上次同步AOF文件的时间距离现在超过一秒，那么再次对AOF文件进行同步，同步的操作由一个线程专门负责执行。</li>\n<li>always：将aof_buf中的所有内容写入AOF文件并同步AOF文件。<br>不管是哪一种选项，都会将aof_buf缓存区中的内容写到AOF文件中，但是同步的时机不一样，这主要和文件的写入和同步在操作系统中有关。</li>\n</ul>\n<p>关于操作系统中文件的写入和同步：为了提高文件的写入效率，现代计算机操作系统中，当用户调用write函数的时候，会将数据先写入一个缓存区中，等缓存区的大小超过限制或被填满后，才会真正的同步到磁盘中。这种做法虽然高效，但如果在数据写入缓存区但还没有同步到磁盘的时候，计算机停机将会丢失数据。所以操作系统提供了fsync和fdatasync两个同步函数强制同步缓存区中的数据到磁盘中。</p>\n<h3 id=\"AOF文件的载入和数据还原\"><a href=\"#AOF文件的载入和数据还原\" class=\"headerlink\" title=\"AOF文件的载入和数据还原\"></a>AOF文件的载入和数据还原</h3><p>AOF文件中有所有重建数据库数据的写入命令，只需要将命令重新执行一遍即可。具体实现为：由于Redis的写入命令是需要从客户端执行的，所以服务端会创建一个伪客户端，负责执行AOF中的命令。伪客户端将把AOF中的命令一条条的读取出来执行，直到所有的命令执行完成。</p>\n<h3 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h3><p>由于AOF是通过保存写入命令来实现持久化的，每次写入的命令都会存到文件中，随着时间的流逝，AOF文件会越来越大，以至于AOF文件载入的时候非常的耗时。所以Redis提供了一个AOF重写的功能，使用重写后的文件来代替原来的AOF文件。</p>\n<h5 id=\"重写的原理\"><a href=\"#重写的原理\" class=\"headerlink\" title=\"重写的原理\"></a>重写的原理</h5><p>Redis会从数据库中读取键现在的值，然后使用一条命令保存这个值，这样就可以保存所有的key的最新的值，并且减小AOF的大小。</p>\n<h4 id=\"AOF后台重写\"><a href=\"#AOF后台重写\" class=\"headerlink\" title=\"AOF后台重写\"></a>AOF后台重写</h4><p>由于重写是比较耗时的，所以Redis将重写的功能放在一个子进程中，这样主进程还可以继续处理客户端的请求。但是，由于在子进程在重写的期间，主进程还在接受写的操作，可能会修改正在重写的数据，造成数据不一致，所以Redis设置了一个重写缓冲区。当Redis服务器执行完一个写命令的时候，会同时将该命令写入AOF缓冲区和AOF重写缓冲区。当进行重写的时候，Redis启用子进程进行AOF重写，Redis服务器继续处理客户端的请求，并将写入的命令放入两个缓冲区中。当子进程完成AOF重写，会向父进程发送一个信号，父进程接收到信号后会调用一个信号处理函数，将AOF重写缓冲区中的数据同步到AOF文件中，并原子性的用新的AOF文件替代旧的AOF文件。整个过程中只有在信号处理函数在处理的时候会阻塞服务器进程。这个就是BGREWRITEAOF命令的实现原理。</p>\n","tags":["Redis"]},{"title":"Redis持久化：RDB","url":"/2018/05/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9ARDB/","content":"<h3 id=\"什么是RDB持久化\"><a href=\"#什么是RDB持久化\" class=\"headerlink\" title=\"什么是RDB持久化\"></a>什么是RDB持久化</h3><p>RDB持久化是Redis的持久化方式之一，也被称为快照持久化，是将某一个时间节点的Redis内存中数据保存到磁盘上，生成一个RDB文件。之后，用户可以将这份文件进行备份，复制到其他的服务器上创建具有相同状态的Redis服务器副本，也可以用于服务器重启恢复到原来的状态。</p>\n<a id=\"more\"></a>\n<h3 id=\"Redis中RDB持久化配置\"><a href=\"#Redis中RDB持久化配置\" class=\"headerlink\" title=\"Redis中RDB持久化配置\"></a>Redis中RDB持久化配置</h3><p>在Redis中，可以配置RDB文件保存的目录、RDB文件的名称，还有同步的时机。配置文件为redis.conf，主要的RDB配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#保存rdb文件的名称，默认为dump.rdb</span><br><span class=\"line\">dbfilename dump.rdb</span><br><span class=\"line\"></span><br><span class=\"line\"># 保存RDB文件的目录</span><br><span class=\"line\">dir .</span><br><span class=\"line\"></span><br><span class=\"line\">#如果指定的秒数和数据库写操作次数都满足了就将数据库保存,默认就是如下配置，需要设置为其他的配置，修改下面配置即可。        </span><br><span class=\"line\">#   900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）    </span><br><span class=\"line\">#   300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）    </span><br><span class=\"line\">#   60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class=\"line\">save 900 1    </span><br><span class=\"line\">save 300 10    </span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n<h3 id=\"Redis生成RDB文件的方式\"><a href=\"#Redis生成RDB文件的方式\" class=\"headerlink\" title=\"Redis生成RDB文件的方式\"></a>Redis生成RDB文件的方式</h3><p>Redis有如下几种方式，可以让服务器生成RDB文件：</p>\n<ul>\n<li>客户端向Redis服务器发送BGSAVE命令，Redis服务器会调用fork创建一个子进程，子进程负责将快照写到磁盘上，父进程会继续处理客户端的请求。</li>\n<li>客户端向Redis服务器发送SAVE命令，Redis服务器在接到SAVE命令的时候，会将数据同步到RDB文件中，在此之间，服务器处于阻塞状态，不会处理其他的请求。</li>\n<li>当用户配置了save选项的时候，一旦save选项满足，则会自动调用BGSAVE命令进行持久化操作。</li>\n<li>Redis通过SHUTDOWN命令关闭服务器或者收到标准的TERM信号时，会执行SAVE命令进行持久化。</li>\n<li>当一个Redis服务器连接另一个Redis服务器，并向对方发送SYNC命令来进行一次复制的时候，如果主服务器没有执行BGSAVE操作，或者主服务器不是刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE操作。</li>\n</ul>\n<p>需要注意的是：</p>\n<ul>\n<li>如果在BGSAVE命令执行期间，客户端向服务器发送SAVE命令，服务器会拒绝执行SAVE命令，防止产生竞争条件。</li>\n<li>如果在SAVE命令执行期间，客户端向服务器发送BGSAVE命令，服务器会拒绝执行BGSAVE命令，防止产生竞争条件。</li>\n<li>BGSAVE和GBREWRITEAOF不能同时执行，如果BGSAVE正在执行，客户端发送的BGREWRITEAOF命令将延迟在BGSAVE命令执行完毕再执行。如果是GBREWRITEAOF正在执行，客户端发送的BGSAVE将会被拒绝执行。</li>\n</ul>\n<h3 id=\"关于Redis载入RDB文件\"><a href=\"#关于Redis载入RDB文件\" class=\"headerlink\" title=\"关于Redis载入RDB文件\"></a>关于Redis载入RDB文件</h3><p>当Redis需要读取RDB文件恢复到之前的状态时，在读取RDB文件的整个过程中，Redis都是处于阻塞状态。需要注意的是，如果Redis开启了AOF，服务器会优先读取AOF文件来还原数据库的状态，因为AOF文件的更新频率通常比RDB文件高。</p>\n","tags":["Redis"]},{"title":"jps命令详解","url":"/2018/01/29/Jps/","content":"<h3 id=\"jps命令的作用\"><a href=\"#jps命令的作用\" class=\"headerlink\" title=\"jps命令的作用\"></a>jps命令的作用</h3><p>jps命令是JDK中自带的命令，位于bin目录下，其作用是显示当前用户下系统中所有的Java进程的相关信息，比如pid。有了这个命令，可以很方便的显示Java进程，不过显示的是当前用户的所有Java进程，不能根据项目名称查找，如果需要查找某个特定的Java程序，可以使用ps -ef | grep JavaName。</p>\n<a id=\"more\"></a>\n<h3 id=\"jps的实现原理\"><a href=\"#jps的实现原理\" class=\"headerlink\" title=\"jps的实现原理\"></a>jps的实现原理</h3><p>jsp的实现原理很简单，主要是程序在启动的时候，会在java.io.tmpdir指定的临时目录下，生成一个类似hsperfdata_User的文件夹，里面的文件名称就是以程序的pid命名的，所以显示进程，只需要把文件名列出即可，其他的参数，可以根据文件内容解析获得。</p>\n<p>每中系统的java.io.tmpdir可能不一样，可以通过如下代码找到指定的临时文件目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.getProperty(&quot;java.io.tmpdir&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>在获取到这个目录之后，打开该目录，在下面寻找hsperfdata_User文件夹，进入即可看到所有的程序进程文件，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x   4 user  staff    136  1 29 20:22 ./</span><br><span class=\"line\">drwx------@ 52 user  staff   1768  1 29 20:21 ../</span><br><span class=\"line\">-rw-------   1 user  staff  32768  1 29 20:06 447</span><br><span class=\"line\">-rw-------   1 user  staff  32768  1 29 20:22 544</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这下面有两个文件，名称分别是447、544，我们可以使用jsp命令验证是否是上面说的实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">user-4:~ user$ jps</span><br><span class=\"line\">544 Launcher</span><br><span class=\"line\">585 Jps</span><br><span class=\"line\">447</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里有三个java进程，注意一下，多的那一个是jps自己的进程，其他的两个是系统中启动的。</p>\n<h3 id=\"jps命令使用\"><a href=\"#jps命令使用\" class=\"headerlink\" title=\"jps命令使用\"></a>jps命令使用</h3><p>为了方面演示，首先写一个程序，并一直运行，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class JpsDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] agrs) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(60 * 60);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先看一下直接使用jps显示的内容,这里只展示演示的进程(后面也只展示相关的进程)：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">user-4:~ user$ jps </span><br><span class=\"line\">625 JpsDemo</span><br></pre></td></tr></table></figure></p>\n<p>首先，如果不知道jps有什么命令，以及格式，可以通过jps -help查看：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">user-4:~ user$ jps -help</span><br><span class=\"line\">usage: jps [-help]</span><br><span class=\"line\">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">Definitions:</span><br><span class=\"line\">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>-q:显示pid，不显示class名称以及传递给main方法的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">user-4:~ user$ jps -q</span><br><span class=\"line\">625</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-m:显示传递给main方法的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">user-4:~ user$ jps -m</span><br><span class=\"line\">625 JpsDemo test test1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-l:显示启动类完整的包名或者应用程序jar包完整的路径名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">user-4:~ user$ jps -l</span><br><span class=\"line\">625 com.xiaohu.test.JpsDemo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-V:显示传递给JVM的参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">user-4:~ user$ jps -l</span><br><span class=\"line\">644 JpsDemo -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:50171,suspend=y,server=n -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java自带的jps命令方便查看该用户下所有的Java进程，特别是有的Java进程，我们不知道名称，比如idea，eclipse等等，-v和-m等参数可以让我们快速的知道启动时传递给虚拟机以及程序的参数。但是，jps不能根据某个应用名称查看，而是把所有的都显示出来，对于运行大量的Java程序的系统，这个命令就不那么让人感觉到爽了。</p>\n","tags":["Java监控工具"]},{"title":"Java多线程之同步容器","url":"/2018/01/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%E9%9B%86%E5%90%88/","content":"<h3 id=\"同步容器的作用\"><a href=\"#同步容器的作用\" class=\"headerlink\" title=\"同步容器的作用\"></a>同步容器的作用</h3><p>Java中的容器主要为List、set、Map、Queue，这些容器都有不同的实现类，比如ArrayLIst、HashSet、HashMap、PriorityQueue等等，但是大部分都是非线程安全的，意味着在多线程访问的时候，必须通过程序做同步访问操作。</p>\n<p>于是，Java提供了这些容器的线程安全版本，也就是同步容器，使用同步容器的时候就不用再去做同步的控制。</p>\n<a id=\"more\"></a>\n<h3 id=\"Java中的同步容器\"><a href=\"#Java中的同步容器\" class=\"headerlink\" title=\"Java中的同步容器\"></a>Java中的同步容器</h3><p>Java中的同步容器主要有以下几类：</p>\n<ul>\n<li>Vector: Vector实现了List接口，内部就是一个动态的数组，和ArrayList类似，不同是的，Vector类中的方法都是被synchronized标识的，所以这个类是一个同步容器。</li>\n<li>Stack:Stack继承了Vector，是一个动态的栈，同样的，Stack的所有方法都被synchronized标识，也是一个同步容器。</li>\n<li>Hashtable:Hashtable实现了Map接口，其作用和HashMap类似，不同的是Hashtable中的所有方法都是被synchronized标识的，所以也是一个同步容器。</li>\n<li>Collections:Collections是一个集合的工具类，里面提供了各种静态的方法来创建同步容器，静态方法都以synchronizedXXX()开头，创建各种容器的同步版本。</li>\n</ul>\n<h3 id=\"同步容器的缺陷\"><a href=\"#同步容器的缺陷\" class=\"headerlink\" title=\"同步容器的缺陷\"></a>同步容器的缺陷</h3><p>在上面介绍各种同步容器的时候，看到所有的同步容器的实现都是采用synchronized的方式实现方法的同步，而通过synchronized的方式同步，在同一时刻，只能有一个线程可以访问该方法，性能比较差。所以，这些同步容器都有一个缺陷，那就是性能会较低。</p>\n","tags":["多线程"]},{"title":"Java多线程之ThreadLocal","url":"/2018/01/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal/","content":"<h3 id=\"ThreadLocal的作用\"><a href=\"#ThreadLocal的作用\" class=\"headerlink\" title=\"ThreadLocal的作用\"></a>ThreadLocal的作用</h3><p>ThreadLocal的作用是提供线程内的局部变量，这个变量在同一个线程的生命周期内起作用，可以减少同一个线程内多个方法之前传入公共资源的复杂性，并且隔离其他线程。下面是一个使用ThreadLocal的例子：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class MyThreadLocal &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final ThreadLocal&lt;Integer&gt; myThreadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected Integer initialValue() &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    static class MyRunnable implements Runnable &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;初始值为：&quot; + myThreadLocal.get());</span><br><span class=\"line\">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(1);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                myThreadLocal.set(myThreadLocal.get() + 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;最后的值为：&quot; + myThreadLocal.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">            new Thread(new MyRunnable()).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Thread-1初始值为：0</span><br><span class=\"line\">Thread-0初始值为：0</span><br><span class=\"line\">Thread-2初始值为：0</span><br><span class=\"line\">Thread-3初始值为：0</span><br><span class=\"line\">Thread-4初始值为：0</span><br><span class=\"line\">Thread-1最后的值为：5</span><br><span class=\"line\">Thread-2最后的值为：5</span><br><span class=\"line\">Thread-4最后的值为：5</span><br><span class=\"line\">Thread-3最后的值为：5</span><br><span class=\"line\">Thread-0最后的值为：5</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，当我们把变量保存在ThreadLocal中之后，并不会因为多线程而让实例变量被多个线程一起访问，而是每个线程访问的都是一份独立的变量，所以ThreadLocal是线程内提供的局部变量。当每个线程需要有一份独立的数据时，ThreadLocal是一个不错的实现方法，但如果需要多个线程共同访问同一份数据，又要考虑多线程并发的问题，则需要使用同步的方式，不要把ThreadLocal的作用弄错了。</p>\n<h3 id=\"ThreadLocal的实现\"><a href=\"#ThreadLocal的实现\" class=\"headerlink\" title=\"ThreadLocal的实现\"></a>ThreadLocal的实现</h3><h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>ThreadLocal的构造方法就一个，而且是一个空的构造方法，内部什么都不做，很简单。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public ThreadLocal() &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"initialValue-方法\"><a href=\"#initialValue-方法\" class=\"headerlink\" title=\"initialValue()方法\"></a>initialValue()方法</h4><p>initialValue()方法用来设置ThreadLocal的初始值，实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected T initialValue() &#123;</span><br><span class=\"line\">       return null;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个protected类型的方法，使用者可以重写改方法，初始化默认的值。需要注意的是该方法调用的时机，该方法会在调用get()方法的时候第一次被调用，但是如果第一次调用的是set()方法，则不会调用该方法。而且该方法一般只会调用一次，除非调用了remove()方法后又调用了get()方法。具体参考set()、get()、remove()方法的实现。</p>\n<h4 id=\"set-方法\"><a href=\"#set-方法\" class=\"headerlink\" title=\"set()方法\"></a>set()方法</h4><p>set()方法是用来设置当前线程的值，具体的实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void set(T value) &#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        if (map != null)</span><br><span class=\"line\">            map.set(this, value);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>set()方法的思路大致为：</p>\n<ol>\n<li>通过Thread.currentThread()方法获取到当前的线程</li>\n<li>根据当前线程获取到一个ThreadLocalMap，getMap()的实现如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class=\"line\">       return t.threadLocals;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以看到，获取的ThreadLocalMap是Thread的一个成员变量，getMap()只是返回这个成员变量，具体的实现逻辑在Thread中，下面看一下Thread中怎么定义ThreadLocalMap的：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class=\"line\">static class ThreadLocalMap &#123;</span><br><span class=\"line\">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">        Object value;</span><br><span class=\"line\">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">            super(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  private Entry[] table;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Thread中定义了一个成员变量ThreadLocalMap，这个Map是内部定义的一个类，自定义的Entry数组保存数据，Entry使用ThreadLocal作为key,保存需要的value。</p>\n<ol start=\"3\">\n<li>如果ThreadLocalMap不是空的，则调用ThreadLocalMap的set方法，以当前ThreadLocal为key，保存value。</li>\n<li>如果ThreadLocalMap是空的，则调用createMap()方法，创建一个ThreadLocalMap，并往里面插入value。该方法实现如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void createMap(Thread t, T firstValue) &#123;</span><br><span class=\"line\">       t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get()方法\"></a>get()方法</h4><p>get()方法用来获取与当前线程相关的ThreadLocal中的值。具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public T get() &#123;</span><br><span class=\"line\">      Thread t = Thread.currentThread();</span><br><span class=\"line\">      ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">      if (map != null) &#123;</span><br><span class=\"line\">          ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class=\"line\">          if (e != null) &#123;</span><br><span class=\"line\">              @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">              T result = (T)e.value;</span><br><span class=\"line\">              return result;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setInitialValue();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>get()方法的思路大致如下：</p>\n<ol>\n<li>通过Thread.currentThread()方法获取到当前的线程</li>\n<li>根据当前线程获取到一个ThreadLocalMap</li>\n<li>如果ThreadLocalMap不为空，则进入第4步，否则进入6步</li>\n<li>根据ThreadLocal引用为key，获取ThreadLocalMap中的entry</li>\n<li>如果entry不为空，则获取里面的value，返回value，如果entry为空，则进入第6步</li>\n<li>如果ThreadLocalMap为空或者Entry为空，则调用setInitialValue()方法，返回方法的返回值。setInitialValue()实现如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private T setInitialValue() &#123;</span><br><span class=\"line\">        T value = initialValue();</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        if (map != null)</span><br><span class=\"line\">            map.set(this, value);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>setInitialValue()方法首先调用initialValue()方法，这里可以看到上面说的，在调用get()方法的时候才会调用initialValue(),而且是先调用get(),如果先调用set()，由于set()的时候会创建一个ThreadLocalMap，再调用get()就不会走到调用initialValue()的步骤。在调用initialValue()初始化ThreadLocal后，获取当前线程，然后再走类似set()方法的流程，返回初始化的值。</p>\n<p>可以看到ThreadLocal的设计就是每个Thread维护一个ThreadLocalMap变量，这个变量以ThreadLocal实例的引用为key,保存Value，实现线程的局部变量。</p>\n<p>需要注意的是，在设计ThreadLocal的时候，可以采用如下方式：每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。但是没有采用这种方式，主要的原因可能是性能问题：按这种方式的话，每一个Entry的数量是线程的数量，但是使用ThreadLocalMap，Entry的数量是和ThreadLocal的数量一致的。而且使用ThreadLocalMap,在线程销毁的时候,ThreadLocalMap也随之销毁。</p>\n","tags":["多线程"]},{"title":"Java多线程之Lock","url":"/2018/01/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BLock/","content":"<h3 id=\"引入Lock的原因\"><a href=\"#引入Lock的原因\" class=\"headerlink\" title=\"引入Lock的原因\"></a>引入Lock的原因</h3><p>Java提供了一个关键字synchronized用来保证同步访问，那为什么还需要使用Lock？最根本的原因就是使用synchronized会造成线程的阻塞，资源同时只能被一个线程访问，程序效率低。比如，多个线程查询读写文件的时候必须使用同步访问，但是如果使用synchronized的话，不管是读操作还是写操作，都只能有一个线程访问，实际上如果所有的线程都是读取资源文件，不去做同步操作也是可以的，只有当对文件做写操作的时候才需要对资源加锁，防止文件在写入的时候有其他的线程读取文件内容。Lock的引入就可以解决这种问题。<br><a id=\"more\"></a><br>还有一点就是synchronized没有办法显式的释放锁，synchronized只能在代码运行结束或者出现异常的时候才可以释放锁，而Lock可以显示的释放锁，这一点，让同步的机制更加灵活，开发也更加灵活。</p>\n<h3 id=\"Lock中常用的方法\"><a href=\"#Lock中常用的方法\" class=\"headerlink\" title=\"Lock中常用的方法\"></a>Lock中常用的方法</h3><p>Lock在是Java中的一个接口，里面声明了一些方法：</p>\n<ul>\n<li>lock():用来获取锁，如果没有获取到，则等待。</li>\n<li>unLock():释放锁,需要注意的是Lock是需要显式的释放锁，所以需要将lock()放在try块中，unLock()方法放在finally块中，防止异常造成死锁现象。</li>\n<li>tryLock():尝试获取锁，如果获取到锁，则返回true，否则返回false,这个方法不是阻塞的，也就是说会立刻返回结果。</li>\n<li>tryLock(long time, TimeUnit unit):这个方法和tryLock()类似，不一样的是这个方法如果没有获取到锁，会等待指定的时间，如果指定的时间没有获取到锁，返回false，获取到锁则返回true。</li>\n<li>lockInterruptibly():当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</li>\n</ul>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p>ReentrantLock是Lock的唯一实现，这是一个重入锁。主要实现了Lock中的方法，并且提供一些新的方法，具体的使用如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ReentrantLockThread implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Integer value = 0;</span><br><span class=\"line\">    private Lock lock = new ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            value++;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;获取了锁: value is &quot; + value);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;释放了锁: value is &quot; + value);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ReentrantLockThread reentrantLockThread = new ReentrantLockThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread thread1 = new Thread(reentrantLockThread, &quot;thread1&quot;);</span><br><span class=\"line\">        Thread thread2 = new Thread(reentrantLockThread, &quot;thread2&quot;);</span><br><span class=\"line\">        Thread thread3 = new Thread(reentrantLockThread, &quot;thread3&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">        thread3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果为:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">thread1获取了锁: value is 1</span><br><span class=\"line\">thread1释放了锁: value is 1</span><br><span class=\"line\">thread2获取了锁: value is 2</span><br><span class=\"line\">thread2释放了锁: value is 2</span><br><span class=\"line\">thread3获取了锁: value is 3</span><br><span class=\"line\">thread3释放了锁: value is 3</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h3><p>ReadWriteLock是Java中定义的一个接口，主要是用来表示读写锁的。ReadWriteLock中主要有两个方法：</p>\n<ul>\n<li>readLock():返回一个读锁</li>\n<li>writeLock():返回一个写锁</li>\n</ul>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是ReadWriteLock的实现，里面实现了获取读写锁的逻辑和其他的一些方法。具体的使用方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ReadWriteLockDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void print() &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                readWriteLock.readLock().lock();</span><br><span class=\"line\">                System.out.println(</span><br><span class=\"line\">                        Thread.currentThread().getName() + &quot;读取&quot; + i + &quot;,时间为：&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                readWriteLock.readLock().unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            readWriteLockDemo.print();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            readWriteLockDemo.print();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            readWriteLockDemo.print();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下，可以看到在同一个时间点，不同的线程也在打印:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Thread-0读取0,时间为：1516200749523</span><br><span class=\"line\">Thread-0读取1,时间为：1516200749524</span><br><span class=\"line\">Thread-0读取2,时间为：1516200749524</span><br><span class=\"line\">Thread-0读取3,时间为：1516200749524</span><br><span class=\"line\">Thread-0读取4,时间为：1516200749525</span><br><span class=\"line\">Thread-0读取5,时间为：1516200749525</span><br><span class=\"line\">Thread-0读取6,时间为：1516200749525</span><br><span class=\"line\">Thread-0读取7,时间为：1516200749525</span><br><span class=\"line\">Thread-1读取0,时间为：1516200749525</span><br><span class=\"line\">Thread-1读取1,时间为：1516200749526</span><br><span class=\"line\">Thread-1读取2,时间为：1516200749526</span><br><span class=\"line\">Thread-0读取8,时间为：1516200749526</span><br><span class=\"line\">Thread-1读取3,时间为：1516200749526</span><br><span class=\"line\">Thread-1读取4,时间为：1516200749526</span><br><span class=\"line\">Thread-1读取5,时间为：1516200749526</span><br><span class=\"line\">Thread-0读取9,时间为：1516200749526</span><br><span class=\"line\">Thread-1读取6,时间为：1516200749526</span><br><span class=\"line\">Thread-1读取7,时间为：1516200749526</span><br><span class=\"line\">Thread-1读取8,时间为：1516200749526</span><br><span class=\"line\">Thread-2读取0,时间为：1516200749526</span><br><span class=\"line\">Thread-2读取1,时间为：1516200749527</span><br><span class=\"line\">Thread-1读取9,时间为：1516200749526</span><br><span class=\"line\">Thread-2读取2,时间为：1516200749527</span><br><span class=\"line\">Thread-2读取3,时间为：1516200749527</span><br><span class=\"line\">Thread-2读取4,时间为：1516200749527</span><br><span class=\"line\">Thread-2读取5,时间为：1516200749527</span><br><span class=\"line\">Thread-2读取6,时间为：1516200749527</span><br><span class=\"line\">Thread-2读取7,时间为：1516200749527</span><br><span class=\"line\">Thread-2读取8,时间为：1516200749527</span><br><span class=\"line\">Thread-2读取9,时间为：1516200749527</span><br></pre></td></tr></table></figure></p>\n<p>关于读写锁，如果一个线程已经获取了读锁，其他的线程还可以获取到读锁，不能获取到写锁。如果一个线程获取到了写锁，其他的线程读锁和写锁都不能获取到，只能等待锁释放。</p>\n<h3 id=\"Lock和synchronized的异同\"><a href=\"#Lock和synchronized的异同\" class=\"headerlink\" title=\"Lock和synchronized的异同\"></a>Lock和synchronized的异同</h3><h4 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h4><ul>\n<li>Lock和synchronized都是重入锁，都可以实现同步</li>\n</ul>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><ul>\n<li>Lock是一个接口，synchronized是一个关键字，是Java的内置实现。</li>\n<li>Lock是一个可中断的锁，可以让等待的线程中断等待，而synchronized不可以中断，只能等待代码执行完成或者出现异常</li>\n<li>Lock必须手动获取锁，同时也必须手动的释放锁，使用的时候需要考虑死锁的问题，而synchronized不需要手动释放，不会存在死锁的问题</li>\n<li>Lock是可以判断是否获取到锁的，使用更加灵活</li>\n<li>Lock在读写操作的场景下效率比synchronized高</li>\n<li>Lock可以实现公平锁，而synchronized不是公平锁。公平锁是以请求锁的顺序来获取锁。比如同时有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程会获得该锁。Lock通过在创建对象的时候指定是否为公平锁。</li>\n</ul>\n","tags":["多线程"]},{"title":"Java多线程之synchronized","url":"/2018/01/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSyncronized/","content":"<h3 id=\"多线程引发的安全问题\"><a href=\"#多线程引发的安全问题\" class=\"headerlink\" title=\"多线程引发的安全问题\"></a>多线程引发的安全问题</h3><p>由于线程是共享进程中的所有资源的，那么每个线程都可以去操作进程中的某一个资源，当多个线程操作同一个资源的时候就可能出现线程安全问题。比如两个线程对同一个实例变量做加1的操作，然后打印该变量，如果变量的初始值为0，当两个线程执行完后，打印的结果依次可能不是1和2，而是可能为1和1或者2和2，因为当一个线程对变量进行加1操作之后，在打印变量之前，第二个线程也对该变量做了加1的操作，这样打印的结果就是2和2，或者在第一个线程正在对变量做加1的时候，第二个线程也进来了，它获取到的变量的初始值还是0，结果打印的是1和1。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UnSafeThread implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Integer value = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        value++;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + &quot;: value is &quot; + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        UnSafeThread unSafeThread = new UnSafeThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread thread1 = new Thread(unSafeThread, &quot;thread1&quot;);</span><br><span class=\"line\">        Thread thread2 = new Thread(unSafeThread, &quot;thread2&quot;);</span><br><span class=\"line\">        Thread thread3 = new Thread(unSafeThread, &quot;thread3&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">        thread3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>异常结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">thread1: value is 1</span><br><span class=\"line\">thread2: value is 1</span><br><span class=\"line\">thread3: value is 2</span><br></pre></td></tr></table></figure></p>\n<p>上面的结果只是一种情况，其余的就不贴出来了。可以看到，当多线程在对资源进行访问的时候，如果改变的资源的值，这样就会出现线程安全问题，因为出现的结果和我们预想的不一样。这里的资源不仅仅是实例变量，还包括数据库、文件、或者一个对象等等。</p>\n<p>怎么解决线程安全问题，基本上所有的并发编程在解决线程安全问题的时候，都是采用序列化访问临界资源的方式，在同一个时刻，只能有一个线程访问该资源，其他的线程处于等待的状态。如何实现序列化访问资源，一般可以在资源上加一个锁，当一个线程获取到资源，就为资源加上锁，当线程访问完资源，则释放掉锁，让下一个线程继续访问该资源。</p>\n<h3 id=\"synchronized的作用\"><a href=\"#synchronized的作用\" class=\"headerlink\" title=\"synchronized的作用\"></a>synchronized的作用</h3><p>synchronized是Java中的一个关键字，用来标记一段代码或者一个方法，当多个线程访问被标记的代码块或者方法的时候，这个线程会获取到一个对象锁，而其他的线程由于没有持有锁，就没有办法访问被标记的代码块或者方法，只有当持有锁的线程执行完后，释放了对象锁，其他的线程才有机会访问。<br>synchronized在标记代码块或者方法的时候，需要有一个锁对象。在Java中，每一个对象都拥有一个锁标记，也被称为监视器，线程只有获取该锁，才有资格访问被他控制的代码。所以，在被synchronized标记的代码块中，必须显示的传入一个对象作为锁，而如果在一个方法上，则不需要，因为拥有这个方法的实例对象也可以作为一个锁。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private Object object = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   public void run() &#123;</span><br><span class=\"line\">       synchronized (object) &#123;</span><br><span class=\"line\">           value++;</span><br><span class=\"line\">           System.out.println(Thread.currentThread().getName() + &quot;: value is &quot; + value);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">thread1: value is 1</span><br><span class=\"line\">thread3: value is 2</span><br><span class=\"line\">thread2: value is 3</span><br></pre></td></tr></table></figure></p>\n<p>将代码修改为上面这样，多个线程访问的时候，就不会出现线程安全问题(不管执行多少次)。当然，可以把run()方法中的逻辑抽为一个方法，再被synchronized标记，这便是一个同步方法。</p>\n<h3 id=\"关于synchronized需要注意的地方\"><a href=\"#关于synchronized需要注意的地方\" class=\"headerlink\" title=\"关于synchronized需要注意的地方\"></a>关于synchronized需要注意的地方</h3><ul>\n<li>synchronized是一个互斥锁，即当一个线程拥有锁之后，其他线程是不能访问资源的。</li>\n<li>只能有一个线程访问同一个实例的synchronized方法</li>\n<li>可以有多个线程访问同一个实例的非synchronized方法</li>\n<li>synchronized是一个重入锁，意思就是线程可以进入被它拥有的锁标记的所有代码块或者方法，不需要再次去获取锁，因为都是同一个锁。</li>\n<li>每一个类都有一个锁，用来控制类方法。</li>\n<li>对于使用synchronized标记的方法或者代码块，一旦程序出现异常，虚拟机会自动释放锁，不会造成死锁。</li>\n</ul>\n<p>如果通过反编译字节码可以看到，被synchronized标记的代码块会多出两条指令，monitorenter和monitorexit。monitorenter指令执行时会让对象的锁计数加1，而monitorexit指令执行时会让对象的锁计数减1，对于synchronized方法，执行中的线程识别该方法的 method_info 结构是否有 ACC_SYNCHRONIZED 标记设置，然后它自动获取对象的锁，调用方法，最后释放锁。如果有异常发生，线程自动释放锁。</p>\n","tags":["多线程"]},{"title":"Java中的线程的创建","url":"/2018/01/15/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"<h3 id=\"Java创建线程的三种方式\"><a href=\"#Java创建线程的三种方式\" class=\"headerlink\" title=\"Java创建线程的三种方式\"></a>Java创建线程的三种方式</h3><ul>\n<li>继承Thread</li>\n<li>实现Runnable</li>\n<li>实现Callable</li>\n</ul>\n<h3 id=\"继承Thread创建线程\"><a href=\"#继承Thread创建线程\" class=\"headerlink\" title=\"继承Thread创建线程\"></a>继承Thread创建线程</h3><p>通过继承Thread的方式，可以很快的创建一个线程，Thread中有一个run()方法，只需要重写该方法，将需要另外开启一个线程处理数据(比如一个耗时的计算任务)的逻辑放在里面，然后调用start()方法便可以开启一个新的线程。这里注意调用的是start()方法，如果调用的是run()方法，这个方法是一个普通方法，整个代码的逻辑就和单线程一样。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class MyThread extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 重写run方法，实现自己的逻辑</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;进入：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(10);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;退出：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;进入：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread myThread = new MyThread();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;退出：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">进入：main</span><br><span class=\"line\">退出：main</span><br><span class=\"line\">进入：Thread-0</span><br><span class=\"line\">退出：Thread-0</span><br></pre></td></tr></table></figure></p>\n<p>上面通过继承Thread创建了一个线程，通过Thread方法打印当前线程的名称，并让这个线程睡眠10秒。由于线程睡眠了10秒，在main线程运行结束后，自定义的线程还在运行，可见这是一个独立的线程。</p>\n<h3 id=\"实现Runnable创建线程\"><a href=\"#实现Runnable创建线程\" class=\"headerlink\" title=\"实现Runnable创建线程\"></a>实现Runnable创建线程</h3><p>通过实现Runnabel接口，实现里面的run()方法，将业务逻辑放在run()方法中，然后将实现的Runnable对象作为参数传递给Thread，调用start()方法，也可以创建线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class MyRunnableThread implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 实现run方法，将业务逻辑放在里面</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;进入：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(10);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;退出：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;进入：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        MyRunnableThread myRunnableThread = new MyRunnableThread();</span><br><span class=\"line\">        Thread thread = new Thread(myRunnableThread);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;退出：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的程序运行结果和继承Thread创建线程一样。如果业务逻辑比较简单，在Java8之后，可以使用lambda表达式实现，代码更加简洁。</p>\n<h3 id=\"实现Callable创建线程\"><a href=\"#实现Callable创建线程\" class=\"headerlink\" title=\"实现Callable创建线程\"></a>实现Callable创建线程</h3><p>通过实现Callable也可以创建线程，和实现Runnable类似，不同的点是Callable是实现call()方法，这个方法可以返回值或者抛出异常，通过FutureTask，可以获取到返回的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class MyCallableThread implements Callable &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 实现call方法，将业务逻辑放在里面</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object call() &#123;</span><br><span class=\"line\">        System.out.println(&quot;进入：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(10);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;退出：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">        return &quot;return Data&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;进入：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        MyCallableThread callableThread = new MyCallableThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        FutureTask futureTask = new FutureTask(callableThread);</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(futureTask).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(&quot;自定义线程返回的值为：&quot; + futureTask.get());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;退出：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">进入：main</span><br><span class=\"line\">进入：Thread-0</span><br><span class=\"line\">退出：Thread-0</span><br><span class=\"line\">自定义线程返回的值为：return Data</span><br><span class=\"line\">退出：main</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，通过FutureTask，可以拿到线程中返回的值，但是一旦使用了get()方法，就会让获取返回值的线程阻塞，知道计算线程返回结果，那这样和在同一个线程中计算有什么区别呢？区别在于主线程可以同步做一些可以并行的操作，节约时间。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上面的三种方式都可以创建一个线程，既然这样，为什么还需要三种方式呢？首先通过Callable这种方式可以获取到返回值，这个特点比较明显。而继承Thread和实现Runnable这两种方式的区别主要是两点：(1)由于Java不能多继承，而可以多实现，这样通过实现的方式，线程类可以继承其他的类。(2)Runnable其实是一个任务，并不是线程本身，而是将任务作为参数传递给线程。可以将复杂的计算任务封装到Runnable中，使用多个线程进行计算。当然，这里由于是多个线程计算同一个任务，就不免涉及到多线程的问题。</p>\n","tags":["多线程"]},{"title":"线程和进程","url":"/2018/01/15/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/","content":"<p><img src=\"http://pqpk8oay4.bkt.clouddn.com/1.jpg?attname=&amp;e=1556533872&amp;token=wmeDBoUdi2BnZQAl32PhB5GzgXvLMCV9oQUx4Ihc:UmzF-zSk9I3HW6kA1ytVSB5Ws3g\" alt=\"avatar\"></p>\n<h3 id=\"什么是进程\"><a href=\"#什么是进程\" class=\"headerlink\" title=\"什么是进程\"></a>什么是进程</h3><p>在百度百科中，进程有两种定义，一种是狭义定义：进程是正在运行的程序实例，比如微信、Tomcat、MySQL，这些就是一个个进程。另一种就是广义的定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，它是操作系统动态执行的基本单元。在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>\n<p>进程主要有两个特点，一是进程是一个实体，操作系统会为它分配独立的地址空间，二是进程是一个执行中的程序，程序是没有生命的实体，只有当处理器赋予它生命，它才是一个活动的实体，这个实体才叫做进程。</p>\n<a id=\"more\"></a>\n<h3 id=\"进程的来由\"><a href=\"#进程的来由\" class=\"headerlink\" title=\"进程的来由\"></a>进程的来由</h3><p>最初计算机被设计出来是为了解决数学计算问题的，当用户输入特定的指令，计算机执行一个操作，在用户输入指令或思考等耗时的操作时，计算机是一直处于等待的状态，这样显然是浪费计算机资源的表现，计算机的使用效率特别的低。</p>\n<p>后来，为了解决这个问题，出现了批处理操作系统。在批处理操作系统中，用户可以预先准备需要执行的一系列操作指令以及数据，一次性的让计算机执行，这样减少了用户设计、输入指令和数据的时间，进一步提升了计算机的使用效率。</p>\n<p>但是，人们发现这样的设计还是存在一些问题，比如，当程序执行的过程中需要进行IO操作，而IO操作需要消耗的CPU资源是比较少的，大部分都是分派给DMA完成的。所以在这一段时间内，CPU是一直处于等待状态的。于是人们想，如果在执行IO操作的时候，是否可以让另一个任务执行，当IO操作完成，暂停当前的任务，在回到原来的任务继续执行。当然，这里存在着许多的问题，比如如何区分每个任务的的数据，当程序暂停后，如何保存之前的运行状态。</p>\n<p>于是，进程的概念就出现了。上面说了，进程就是一个运行的程序实例，操作系统会为它分配一定的内存空间，这样每个程序之间就不会有数据干扰问题，并且进程会保存程序的运行状态，这样就可以进行进程的切换，当进程恢复的时候，就可以读取到之前的运行环境。</p>\n<h3 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h3><p>线程是程序执行流的最小单元，是一个单一的顺序控制流程。它是进程中的一个实体，是被系统独立调度和分派的基本单元，线程自己不拥有系统资源，但它可以和同属一个进程的其他线程共享进程的所有资源。</p>\n<h3 id=\"线程的来由\"><a href=\"#线程的来由\" class=\"headerlink\" title=\"线程的来由\"></a>线程的来由</h3><p>进程的出现极大的提高的计算机的工作效率，让程序可以在计算机中并发的运行，但是就一个独立的进程来看，其使用效率并不高效，因为进程还是一个顺序的执行体，一旦其中的某个操作需要耗时很久，进程就必须处于等待的状态。当线程出现之后，我们可以把那些耗时的操作放在一个线程中处理，程序还可以做其他的事情。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>由于进程之间是独立的内存空间，不共享资源，所以多个进程的时候不需要考虑任何问题。但是对于一个进程中的多个线程，由于线程是共享进程中的所有资源的，所以如何让进程中的资源被多个线程正确的访问是我们在进行多线程设计中需要深入考虑的问题。</p>\n","tags":["多线程"]}]